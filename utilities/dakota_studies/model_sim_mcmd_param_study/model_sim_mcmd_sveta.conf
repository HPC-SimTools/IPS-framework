IPS_ROOT = /scratch/scratchdirs/sveta/ips
OUTPUT_PREFIX = 

RUN_ID = Run_8                   # Indentifier for this simulation run
TOKAMAK_ID = mcmc_2               # Identifier for tokamak simulated
SHOT_NUMBER = 1                  # Identifier for specific case for this tokamak (not necessarily a number)

SIM_NAME = ${RUN_ID}_${TOKAMAK_ID}_${SHOT_NUMBER}  # Name of current simulation
SIM_ROOT = $IPS_ROOT #/scratch/scratchdirs/sveta/code_camp/$SIM_NAME
LOG_FILE = model_sim
LOB_LEVEL = DEBUG

PLASMA_STATE_WORK_DIR = $SIM_ROOT/work/plasma_state # Where to put plasma state files as the simulation evolves 
CURRENT_STATE = ${SIM_NAME}_ps.cdf
PRIOR_STATE = ${SIM_NAME}_psp.cdf
NEXT_STATE = ${SIM_NAME}_ps_next.cdf
CURRENT_EQDSK = ${SIM_NAME}_ps.geq
CURRENT_CQL = ${SIM_NAME}_ps_CQL.nc
CURRENT_DQL = ${SIM_NAME}_ps_DQL.nc
CURRENT_JSDSK = ${SIM_NAME}_ps_jsdsk.nc

# Stuff for connecting to the portal - This is machine dependent
COMMENT = Testing dbb 0909#21 model sim A run comment picked up by the portal
#TAG = Grouping Tag					# A tag that enables related runs to be retrieved together
USER   = sveta					# Optional, if missing the unix username is used
#PORTAL_URL = http://swim.gat.com:8080/monitor		# URL for the portal
#RUNID_URL  = http://swim.gat.com:4040/runid.esp


PLASMA_STATE_FILES1 = $CURRENT_STATE $PRIOR_STATE  $NEXT_STATE  # What files constitute the plasma state
PLASMA_STATE_FILES = $PLASMA_STATE_FILES1  $CURRENT_EQDSK $CURRENT_CQL $CURRENT_DQL $CURRENT_JSDSK

PLATFORM =                                          # Simulation Platform
BATCH_SYSTEM =                                      # Which Batch system to use
#MPIRUN = mpirun                                     # How are MPI jobs launched (interactively)
SIMULATION_MODE = SINGLE_STEP | RESTART             # Simulation mode 
INITIALIZATION_MODE =                               # Initialization Mode
MACHINE_CONFIG_FILE =                               # Machine configuration file

[PORTS]
   NAMES = INIT DRIVER MONITOR EPA RF_IC NB FUS
#   NAMES = INIT DRIVER MONITOR EPA RF_IC FP NB
   
   [[DRIVER]]                                       # REQUIRED Port section 
      IMPLEMENTATION = GENERIC_IPS_DRIVER
                                                    
                                                                                                        # How is the simulation initialized 
                                                    # (generate the very first state - if needed)
   [[INIT]]                                         # REQUIRED Port section (check currently 
      IMPLEMENTATION = minimal_state_init 
   
  [[RF_IC]]
      IMPLEMENTATION = model_RF_IC 

  [[FP]]
      IMPLEMENTATION = minority_model_FP
    
  [[FUS]]
      IMPLEMENTATION = model_FUS

  [[NB]]
      IMPLEMENTATION = model_NB

   [[EPA]]
      IMPLEMENTATION = model_EPA
           
   [[MONITOR]]
      IMPLEMENTATION = monitor_comp_4

# Individual configuration sections

# Component sepcification (entries similar for all components)
# NAME entry MUST match the name of the python class that implements the component

[minimal_state_init]
    CLASS = minimal_state_init
    SUB_CLASS = dbb
    NAME = minimal_state_init
    NPROC = 1
    BIN_PATH = $IPS_ROOT/bin
        INPUT_DIR = $IPS_ROOT/components/$CLASS/$SUB_CLASS
        INPUT_FILES = 
        OUTPUT_FILES = $CURRENT_STATE 
    SCRIPT = $BIN_PATH/minimal_state_init.py

[GENERIC_IPS_DRIVER]
    CLASS = drivers
    SUB_CLASS = dbb
    NAME = epa_ic_nb_fus_driver 
    NPROC = 1
    BIN_PATH = $IPS_ROOT/bin
        INPUT_DIR = $IPS_ROOT/components/$CLASS/$SUB_CLASS
        INPUT_FILES = 
        OUTPUT_FILES = 
    SCRIPT = $BIN_PATH/mcmd_epa_ic_nb_fus_driver.py
    
[model_EPA]
    CLASS = epa
    SUB_CLASS = model_epa
    NAME = model_EPA
    NPROC = 1
    BIN_PATH = $IPS_ROOT/bin
    INPUT_DIR = $IPS_ROOT/components/$CLASS/$SUB_CLASS
        INPUT_FILES = model_epa_eqdsk_input.nml 40700_2_ps.cdf 40700_2_ps.geq 
        OUTPUT_FILES = 
    SCRIPT = $BIN_PATH/model_epa_ps_init.py

[model_RF_IC]
    CLASS = rf
    SUB_CLASS = model_RF_IC
    NAME = model_RF_IC_2 
    NPROC = 1
    BIN_PATH = $IPS_ROOT/bin
    INPUT_DIR = $IPS_ROOT/components/$CLASS/$SUB_CLASS
        INPUT_FILES = model_RF_IC_input.nml
        OUTPUT_FILES =
    SCRIPT = $BIN_PATH/model_RF_IC_2_mcmd.py

[model_NB]
    CLASS = nb 
    SUB_CLASS = model_NB
    NAME = model_NB
    NPROC = 1
    BIN_PATH = $IPS_ROOT/bin
    INPUT_DIR = $IPS_ROOT/components/$CLASS/$SUB_CLASS
        INPUT_FILES = model_NB_input.nml
        OUTPUT_FILES =
    SCRIPT = $BIN_PATH/model_NB_2.py
    
[model_FUS] 
    CLASS = fus 
    SUB_CLASS = model_fus
    NAME = model_FUS 
    NPROC = 1
    BIN_PATH = $IPS_ROOT/bin
    INPUT_DIR = $IPS_ROOT/components/$CLASS/$SUB_CLASS
        INPUT_FILES = model_FUS_input.nml
        OUTPUT_FILES =
    SCRIPT = $BIN_PATH/model_FUS.py

[minority_model_FP]
    CLASS = fp
    SUB_CLASS = minority_model
    NAME = minority_model_FP_2 
    NPROC = 1
    BIN_PATH = $IPS_ROOT/bin
    INPUT_DIR = $IPS_ROOT/components/$CLASS/$SUB_CLASS
        INPUT_FILES = minority_model_FP.nml
        OUTPUT_FILES =
    SCRIPT = $BIN_PATH/minority_model_FP_2.py


[monitor_comp_4]
    CLASS = monitor
    SUB_CLASS = 
    NAME = monitor
    NPROC = 1
    W3_DIR = /project/projectdirs/m876/www/sveta 
    W3_BASEURL =http://portal.nersc.gov/project/m876/sveta
    TEMPLATE_FILE= basic_time_traces.xml 
    BIN_PATH = $IPS_ROOT/bin
    INPUT_DIR = $IPS_ROOT/components/monitor/monitor_4
    INPUT_FILES = basic_time_traces.xml 
    OUTPUT_FILES = monitor_file.nc
    SCRIPT = $BIN_PATH/monitor_comp_4_5.py
    
 
# Time loop sepecification (two modes for now) EXPLICIT | REGULAR
# For MODE = REGULAR, the framework uses the variables START, FINISH, and NSTEP
# For MODE = EXPLICIT, the frame work uses the variable VALUES (space separated list of time values)

[TIME_LOOP]
   MODE = REGULAR
   START = 0.0
   FINISH = 0.5 
   NSTEP  = 2 
#   VALUES = 
