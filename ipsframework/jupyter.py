"""
This module is designed to help generate JupyterNotebooks to be used with IPS Portal analysis.
Some parts of the script will need direction from users on the Framework side to generate.

Note that this module is currently biased towards working with NERSC (jupyter.nersc.gov), so will attempt to import specific libraries.

To see available libraries on NERSC, run:
  !pip list

...in a shell on Jupyter NERSC.
"""

from typing import List, Optional

import nbformat as nbf

HOOK = '### This cell autogenerated by IPS Framework. DO NOT EDIT UNTIL IPS RUN IS FINALIZED. ###'
"""This hook is used to determine which "cell" the IPS framework should work with.

It is written to a notebook cell on initializing it, and is searched for when adding a data file to it.
"""


def replace_last(source_string: str, old: str, new: str) -> str:
    """Attempt to replace the last occurence of 'old' with 'new' in 'source_string', searching from the right."""
    head, _sep, tail = source_string.rpartition(old)
    return f'{head}{new}{tail}'


def _initial_jupyter_file_notebook_cell(variable: str, initial_data_files: Optional[List[str]] = None) -> str:
    if not initial_data_files:
        initial = ''
    else:
        itemsep = '\n'
        initial = '\n' + itemsep.join([f"'{file}'," for file in initial_data_files])
    return f"""{HOOK}

import os

# NOTE: directory should be sim_name plus the run id from the Portal
# NOTE: add absolute path as a comment to the notebook cell
# Uncomment below line to use any state files saved
#{variable} = os.listdir('data')
# files created during the run
{variable} = [{initial}
]
"""


def initialize_jupyter_notebook(dest: str, src: str, variable_name: str, index: int, initial_data_files: Optional[List[str]] = None):
    """Create a new notebook from an old notebook, copying the result from 'src' to 'dest'.

    Params:
      - dest - location of notebook to create on filesystem
      - src - location of source notebook on filesystem (is not overwritten unless src == dest)
      - variable_name: what to call the variable
      - index: insert new cells at position before this value (will not remove preexisting cells)
      - initial_data_files: optional list of files to initialize the notebook with

    """
    # to avoid conversion, use as_version=nbf.NO_CONVERT
    #
    nb: nbf.NotebookNode = nbf.read(src, as_version=4)

    header = '# Next cell generated by IPS Framework'
    nb['cells'] = (
        nb['cells'][:index]
        + [nbf.v4.new_markdown_cell(header), nbf.v4.new_code_cell(_initial_jupyter_file_notebook_cell(variable_name, initial_data_files))]
        + nb['cells'][index:]
    )

    nbf.validate(nb)
    with open(dest, 'w') as f:
        nbf.write(nb, f)


def add_data_file_to_notebook(dest: str, data_file: str, index: Optional[int] = None):
    """Add data file to notebook list.

    Params:
      - dest: path to notebook which will be modified
      - data_file: data file we add to the notebook
      - index: optional index of the IPS notebook cell. If not provided,
    """
    nb: nbf.NotebookNode = nbf.read(dest, as_version=4)
    if index is None:
        index = next((i for i, e in enumerate(nb['cells']) if HOOK in e['source']), -1)
    if index < 0:
        raise Exception('Cannot find IPS notebook node')
    ips_cell = nb['cells'][index]['source']

    # search from right of string for the ']' character, should work assuming user does not modify the cell past the variable definition
    result = replace_last(ips_cell, ']', f"'{data_file}',\n]")
    nb['cells'][index]['source'] = result

    with open(dest, 'w') as f:
        nbf.write(nb, f)
