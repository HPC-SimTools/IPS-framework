#!/bin/csh -f
# Script wrapper for IPS

echo IPS_WRAPPER Script starting

# $argv[1] is params.in.(fn_eval_num) FROM Dakota
# $argv[2] is results.out.(fn_eval_num) returned to Dakota
set num = `echo $argv[1] | cut -c 11-`

# --------------
# PRE-PROCESSING
# --------------

# Move arguments into meaningful variable names
set PARAM_FILE = $argv[1]
set RESULTS_FILE = $argv[2]

# Use the run number to give IPS a working directory name
set WORKING_DIR = "${PARAMETER_STUDY_DIR}/RUN_${num}"
echo WORKING_DIR is $WORKING_DIR

# Create a work directory with the run number
mkdir $WORKING_DIR

# Incorporate the input values from Dakota into model_epa_input_eqdsk_init.nml
# Note that the INPUT namelist is in the root directory
# and the OUTPUT namelist is in the working directory
$IPS_ROOT/utilities/dakota_studies/dakota_utils/createInputNamelist.py $PARAM_FILE model_epa_input_eqdsk_init.nml "${WORKING_DIR}/model_epa_input_eqdsk_init.nml"

# Insert our working directory into the ips config file as SIM_ROOT
# And save it as a new config file in our working directory
$IPS_ROOT/utilities/dakota_studies/dakota_utils/parseIpsConfig.py $WORKING_DIR $IPS_CONFIG_FILE "${WORKING_DIR}/${IPS_CONFIG_FILE}"

# Move/copy files into run directory
mv $PARAM_FILE $WORKING_DIR

# Go into the working directory
cd $WORKING_DIR

# --------
# ANALYSIS
# --------

# Run the test program with the parameters in model_epa_input_eqdsk_init.nml
$IPS_ROOT/bin/ips --config=model_sim_mcmd_sveta.conf --log=py.log #--debug --platform=$SCRATCH/ips/franklin.conf --log=py.log  --debug

# ---------------
# POST-PROCESSING
# ---------------

# grab the output file generated by ips and do something with it
echo 42 > $RESULTS_FILE

# We copy the output file into its final location AFTER it has been 100% written
# Otherwise Dakota could end up in a race condition
cp $argv[2] ../

# --------
# Clean up
# --------

#drop back to original directory
cd ..
