
I. Design Goals

    A. Handle job management and monitoring on different platforms, especially
    unique DOE petascale ones.
    
    B. Data managment, movement, location, and sophisticated query
    
    C. Minimal perturbation to ongoing scientific research using the extant
    constituent codes and software.
    
    D. Maximize reliability, in part by decoupling
    
    E. Extensibility, programmability, and longevity
    
    F. Leverage existing technology and interoperate with other fusion
    simulation efforts

II. The Swim Portal

    A. General portal ideas and terminology
        1. Web-based, location dependence, launch and reconnect from diff
        sites
        2. customization
        3. portlets and containers
        4. Advantages and disadvantages
            authentication
            centralization
            network connectivity requirements
            use of existing and future portlets
            standards
            [later note SWIM use of scripting in practice lets us change if
            portal tech is replaced in future. for scripts are always with
            us, forever and aye.]

    B. Swim portal in particular
        1. Current portlets [Note: may use "utility" instead of "portlet"]
            myproxy
            job manager
            data manager
            event viewer
            overall script
        2. Event channel and decoupling
        3. Scripting approach used
            [note that they can be used w/o the portal but then the user
            loses the cool data mgmt, web-based monitoring, and reconnect
            capabilities]

III. SWIM Usage

    A. Scripting levels:: overall sim management script, individual
    component scripts, end user run scripts

    B. Individual component script requirements and assumptions
        1. Build: executables available or "make" works
        2. SWIM files (input, output, config, run)
        3. Python utilities
        4. Web accessibility and gatekeeper

    C. Overall simulation script (show Don's example)
        1. Main time loop and component invocations
        2. Cross-component coordination
        3. IPS data consistency

    D. Summary of steps an end user must take

IV. Example: LSA

    A. Application domain covered, components, example workflow

    B. SWIM files (c.f. III.B.2) for reorder, splib

    C. Component scripts for reorder, splib

    D. Overall script for an example workflow

    E. Screen shots: customize, event log, event query, script uploaded,
        splib-generated web page.

V. Example: AORSA + CQL

