\section{SWIM Framework Usage}
\label{sec:usage}

% 
% III. SWIM Usage
% 
%     A. Scripting levels:: overall sim management script, individual
%     component scripts, end user run scripts
% 
%     B. Individual component script requirements and assumptions
%         1. Build: executables available or "make" works
%         2. SWIM files (input, output, config, run)
%         3. Python utilities
%         4. Web accessibility and gatekeeper
% 
%     C. Overall simulation script (show Don's example)
%         1. Main time loop and component invocations
%         2. Cross-component coordination
%         3. IPS data consistency
% 
%     D. Summary of steps an end user must take
% 

Creating a component and using it in a SWIM run is straightforward.
The functions which the framework requires and the use of the Plasma State
Component for passing data between components is detailed
in the IPS Design Document \cite{IPSdoc}. Here the basic directory and scripting
requirements are given.  Three steps are required, but most
computational codes have the more difficult parts (run scripts and build
structures) already done independently of SWIM. Steps are:
%IPSDoc not cited... need to put it in

\begin{enumerator}
    \item Put each code into a separate directory. 
        In the LSA example in
        Section \ref{sec:lsa}, these are
        named after the component they contain and are all under the {\em lsa/}
      directory.

    \item Create five files in the component's directory, with the following
      convention:

        \begin{enumerator}
        \item {\bf SWIM\_component\_required} a list of the required input files.
           This should include ones that are component-specific, i.e., ones
           that are not strictly related to intercomponent interactions.
           That is so the framework can assure all required run-time inputs
           are available before potentially wasting time in batch queues or
           otherwise.

       \item {\bf SWIM\_component\_results} a list of the output files. This is
           actually not used until the end of the run, because a component
           may not know a priori how many or even what files will be
           created. E.g., a file may be created for each time step, and the
           number of timesteps is not known until convergence has been
           achieved or an error tolerance met.

       \item {\bf SWIM\_files} the list of files that the SWIM framework needs for
           correct operation. For the LSA example, this includes just the
           five files in this list.

       \item {\bf SWIM\_config} a file containing any additional information
           required to run the component. That includes application and
           site-dependent information such as the project directory, the
           batch management system (PBS, SLURM, sshd), whether or not the
           job is parallel, and the number of MPI processes to use. This
           can be expanded for any other information the user needs.

       \item {\bf SWIM\_runit} a Python script that actually encapsulates the
           component and makes calls on the framework.
       \end{enumerator}

\end{enumerator}

Once all of these files are in place and the code is built, the SWIM framework does the following to run the job:
\begin{enumerator}
\item job launch script moves any input files that need to be moved and checks to make sure the files are in the right spots.
	\begin{enumerator}
	\item {\bf SWIM\_runit} is called from job launch script.
		\begin{enumerator}
		\item in {\bf SWIM\_runit}, the run is initialized using the {\em initialize} function (from {\bf Framework.py}):
			\begin{enumerator}
			\item check for a valid executable
			\item create a new directory for the run with specified input files and executable
			\end{enumerator}
		\item {\bf SWIM\_runit} calls step (from {\bf Framework.py}):
			\begin{enumerator}
			\item {\em job}, a {\em batch\_mgmt\_script.fsp\_job} object is created to run job
			\item {\em job} is submitted to the queue via {\em submit\_job}
			\item {\em job} is monitored via {\em monitor\_job}, status events are published at regular intervals until the run has ended
			\end{enumerator}
		\item {\bf SWIM\_runit} calls finalize (from {\bf Framework.py}):
			\begin{enumerator}
			\item data manager is notified of output files created during this run via event channel
			\end{enumerator}
		\end{enumerator}
	\end{enumerator}
\end{enumerator}
%         1. Build: executables available or "make" works
%         2. SWIM files (input, output, config, run)
%         3. Python utilities
%         4. Web accessibility and gatekeeper

