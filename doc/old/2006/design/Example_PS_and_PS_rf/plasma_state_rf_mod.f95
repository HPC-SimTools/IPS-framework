MODULE plasma_state_rf_mod

! Version 0.3 7/10/2006 (Batchelor)

    !---------------------------------------------------------------------------
    !
    ! This is the outcome of a meeting at ORNL, 2-5 May 2006. (it actually
    ! includes some aorsa-specific stuff at end temporarily -> I don't think it
    ! really does have anything AORSA specific now: DBB 5/10/06)
    !
    !   Randall Bramley
    !   Department of Computer Science
    !   Indiana University
    !   Bloomington, IN 47405
    !   bramley@cs.indiana.edu
    !   initialized: Thu May  4 14:22:04 EDT 2006
    !
    !   Modifications by DBB to conform to 'Plasma State Interface.doc'
    !
    !   Don Batchelor
    !   ORNL
    !   Oak Ridge, TN 37831
    !   batchelordb@ornl.gov
    !
    !   Module contains data needed by, and generated by, generic RF components.
    !   Input data is retrieved from the Plasma State component by calling module
    !   routine GET_PLASMA_STATE_RF.  Output data from the component is placed in the
    !   Plasma State by calling PUT_PLASMA_SATATE_RF.
    !
    !   When we have modules like this for all components, the Plasma State data
    !   will be the union of all the component data blocks.
    !
    !   Note:   The data in this module is public (to anybody who uses the module)
    !           but data in the Plasma State is still (mostly) encapsulated since
    !           clobbering this module data does not clobber the equivalent data in
    !           in the plasma state store.  It would be possible to clobber Plasma
    !           State RF output data by using this module, corrupting the RF output
    !           data, and misusing the 'write_plasma_state_rf' routine.  But imagine
    !           the peer dissaproval that would incur.
    !
    !   Note:   1D profiles are radial integrals of flux surface averages (I'm not 
    !           so sure now that we should do this Ð DBB 7/14/06)
    !
    !   Note:   The allocatable input data arrays are allocated in the GET_PLASMA_STATE_RF
    !           subroutine below on the basis of array sizes obtained by using
    !           plasma_state_mod and calling PS_GET_PLASMA_STATE.  They shouldn't need
    !           to be deallocated at all because, once the code input file is written,
    !           the PREPARE_CODE_INPUT code dies.  If they do need to be deallocated 
    !           for any reason, then the code that uses this module needs to do it.  For
    !           convenience, and maybe for completeness we could write a module routine to
    !           do that.  Also such a routine would be needed for any component that 
    !           stays in memory and executes multiple steps with out ending execution.
    !
    !           Allocatable output arrays must be allocated in the using program.  This
    !           is because the sizes of the arrays might have changed during the 
    !           component code execution and will not generally be known (for example
    !           in the plasma state).  In turn the PUT_PLASMA_STATE_RF subroutine must
    !           allocate the PS arrays that have the sem-public data.  I realize that 
    !           it is dangerous to have the component routines allocating and modifying
    !           data directly to the Plasma State.  But this is a simple way to get started
    !           and we can do something more secure as we go on.
    !           - DBB 7/15/06
    !
    !---------------------------------------------------------------------------
    
!--------------------------------------------------------------------------
!
!   Other modules used:
!       Unless there is a huge number of declarations coming in, use the "only"
!       qualifier on "use" statements so the reader can tell where the variables are
!       declared and set.
!
!--------------------------------------------------------------------------

    use swim_global_data_mod, only : &
            & rspec, ispec, &               ! int: kind specification for real and integer
            & SWIM_name, SWIM_filename, &   ! derived data types: containing one character string
            & SWIM_error                    ! subroutine: a simple error handling routine

    

    
!--------------------------------------------------------------------------
!
!   Data declarations
!
!--------------------------------------------------------------------------
    
    IMPLICIT NONE
    
!--------------------------------------------------------------------------
!
!   PLASMA STATE DATA for RF COMPONENT
!
!--------------------------------------------------------------------------
   
    !-----------------------------------
    ! Time at beginning and end of time step
    !-----------------------------------
    REAL (KIND = rspec) ::  &
        t0,                 & ! time at beginning of step [msec]
        t1                    ! time at end of step [msec]
   
    !-----------------------------------
    ! Basic Geometry
    !-----------------------------------
    REAL (KIND = rspec) ::  &
        r_axis,             & ! major radius of magnetic axis [m]
        z_axis,             & ! Z of magnetic axis [m]
        r0_mach,            & ! Z of machine center [m]
        z0_mach,            & ! major radius of machine center [m]
        r_min,              & ! major radius of inside of bounding box [m]
        r_max,              & ! major radius of outside of bounding box [m]
        z_min,              & ! Z of bottom of bounding box [m]
        z_max                 ! Z of top of bounding box [m]
            
    !-----------------------------------
    ! Particle Species
    !-----------------------------------
    
    INTEGER :: nspec          ! number of ion species = nspec_th + nspec_nonMax

    !-----------------------------------
    ! Main (thermal) Plasma Species
    !-----------------------------------
    
    INTEGER :: nspec_th       ! number of thermal ion species
    TYPE (SWIM_name), ALLOCATABLE :: &
        s_name(:)             ! names of main species, (0:nspec_th)
    REAL (KIND = rspec), ALLOCATABLE :: &
        q_s(:),             & ! charge of species s [C], (0:nspec_th)
        m_s(:)                ! mass of species s [kg], (0:nspec_th)
    
    INTEGER :: nrho_n         ! number of rho values in thermal species density grid
    REAL (KIND = rspec), ALLOCATABLE :: &
        rho_n_grid(:),      & ! rho values in density grid, (1:nrho_n)
        n_s(:, :),          & ! density profile of species s, (1:nrho_n, 0:nspec_th)
        q_impurity(:),          & ! effective impurity charge profile, (1:nrho_n)
        m_impurity(:)             ! effective impurity mass profile, (1:nrho_n)
 
    INTEGER :: nrho_T         ! number of rho values in temperature grid
    REAL (KIND = rspec), ALLOCATABLE :: &
        rho_T_grid(:),      & ! rho values in temperature grid, (1:nrho_T)
        T_s(:, :)             ! Temperature profile of species s, (1:nrho_T, 0:nspec_th)
 
    INTEGER :: nrho_v_par     ! number of main rho values in parallel velocity grid
    REAL (KIND = rspec), ALLOCATABLE :: &
        rho_v_par_grid(:),  & ! rho values in prallel velocity grid, (1:nrho_v_par)
        v_par_s(:, :)         ! v parallel profile of species s, 
                              ! (1:nrho_v_par, 0:nspec_th)
 
    !-----------------------------------
    ! Non-Maxwellian Species
    !-----------------------------------
    
    INTEGER :: nspec_nonMax   ! number of non-Maxwellian species
    TYPE (SWIM_name), ALLOCATABLE :: &
        nonMax_name(:)        ! names of non-Maxwellian species, (1:nspec_nonMax)
    
    REAL (KIND = rspec), ALLOCATABLE :: &
        q_nonMax_s(:),      & ! charge of species s [C], (1:nspec_nonMax)
        m_nonMaX_s(:)         ! mass of species s [kg], (1:nspec_nonMax)
    
    INTEGER :: ntheta_n       ! number of theta values in 2D density grid

    REAL (KIND = rspec), ALLOCATABLE :: &
        n_nonMax2D_s(:, :,:)  ! 2D density profile of non-Maxwellian species s,
                              ! (1:nrho_n, 1:ntheta_n, 1:nspec_nonMax)

    REAL (KIND = rspec), ALLOCATABLE :: &
        n_nonMax_s(:, :)      ! Flux surface average density profile of 
                              ! non-Maxwellian species s, (1:nrho_n, 1:nspec_nonMax)
 
    TYPE (SWIM_filename), ALLOCATABLE :: &
        dist_fun_s(:)         ! distribution function of non-Maxwellian  
                              ! species s, (1:nspec_nonMax) N.B. For now a distribution
                              ! function type is a file name
 
 
    !-----------------------------------
    ! Magnetics
    !
    ! magnetics: B(x), magnetic field.  Like distribution_fn there is a
    ! user-defined type that contains a file with the data.
    ! AORSA and TORIC get all their magntics data by reading an eqdisk file.
    ! Eventually all the magnetics data will appear separately in the Plasma
    ! state.
    !-----------------------------------

    TYPE (SWIM_filename) :: eqdsk_file  ! eqdisk file
        
    REAL (KIND = rspec) ::  &
        B_axis                   ! Field at magnetic axis [T]

    !--------------------------------------------------------------------------
    !
    ! RF Data
    !
    ! Allow multiple RF sources, ICF, ICRH. So RF_frequency, power, etc may
    ! not be a scalar in that case.
    !   Assumption 1: the RF component invocation will
    !       involve a loop over each RF source, each of which can have its own
    !       RF_frequency, etc.  (vs. adding another dimension to the arrays).
    !   Assumption 2 : each source involves invoking another executable.
    !--------------------------------------------------------------------------
   
    
    INTEGER :: nrf_src        ! number of RF sources
    
    TYPE (SWIM_name), ALLOCATABLE :: &
        rf_src_name(:)            ! names of rf sources, (1:nrf_src)
        
    REAL (KIND = rspec), ALLOCATABLE :: &
        rf_freq_src(:),     & ! frequency of RF source s [MHz], (1:nrf_src)
        rf_power_src(:)       ! power of RF sources [MW], (1:nrf_src)
    
 
    TYPE (SWIM_filename), ALLOCATABLE :: &
        ant_model_src(:)      ! antenna models for RF sources, (1:nrf_src)
   

    !---------------------------------------------------------------------------
    ! Note:
    ! Antenna model is currently defined in a file. The PREPARE_CODE_INPUT program
    ! should extract from it the data needed to define the geometry and operation
    ! i.e. phasing or mode number spectrum
    !
    ! For these, see the example namelist attached to the end
    ! of the aorsa.doc file sent by Fred to Swim list.  For now the data in this
    ! file includes:
    !   nphi =toroidal mode number (find another name not conflicting toroidal angle)
    !   antlen = vertical height of antenna [m]
    !   dpsiant0 = radial thickness of antenna in rho
    !   rant = radial location of antenna in major radius [m]
    !   yant = vertical location of antenna center [m]
    !
    !  N.B. In this scheme the toroidal mode number comes in through the antenna model
    !  The antenna geometry should eventually come from one of the standard machine
    !  definition files. 
    !
    !---------------------------------------------------------------------------
  
  
    ! RF Outputs that go back into the Plasma State.  Profiles are flux surface averages.
    
    ! N.B. We will want to put in 2D power deposition profiles, but I don't think they
    ! are needed for our initial coupling
        
    INTEGER ::  &
        & nrho_prf, &   ! number rho values for RF power deposition grid
          ntheta_prf    ! number of theta values in 2D RF power dep grid
        
    REAL (KIND = rspec), ALLOCATABLE :: &
        rho_prf_grid(:),    & ! rho values in RF power deposition grid, (1:nrho__prf)
        prf2D_src_s(:,:,:,:),   & ! 2D Power deposition from each source into each 
                                  ! species, (1:nrho__prf, 1:nrf_src, 0:nspec)
        prf_src_s(:,:,:),   & ! Power deposition profile from each source into each 
                              ! species, (1:nrho__prf, 1:nrf_src, 0:nspec)
        prf_total_s(:,:)      ! Total rf power deposition profile into each species
                              ! summed over sources, (1:nrho__prf, 0:nspec)
    
        
    INTEGER :: nrho_cdrf      ! number rho values for RF current drive grid
        
    REAL (KIND = rspec), ALLOCATABLE :: &
        rho_cdrf_grid(:),   & ! rho values in RF current drive grid, (1:nrho__cdrf)
        cdrf_src_s(:,:,:),  & ! Driven current profile from each source, in each species
                              ! (1:nrho__cdrf, 1:nrf_src, 1:nspec_nonMax)
        cdrf_total_s(:,:)     ! Total current driven by all sources in each species
    
 
    TYPE (SWIM_filename), ALLOCATABLE :: &
        ql_operator(:)      ! quasilinear operator for each non Maxwellian 
                            ! species, (1:nspec_nonMax)


!--------------------------------------------------------------------------
!
!   End of data declarations
!
!--------------------------------------------------------------------------

CONTAINS
    
!--------------------------------------------------------------------------
!
!   Routines to GET from Plasma State and WRITE to Plasma State
!
!--------------------------------------------------------------------------
   
    
    !-------------------------------------------------------------------
    !
    ! GET_PLASMA_STATE_RF
    !
    ! This routine must call the plasm_state_mod function PS_GET_PLASMA_STATE which loads
    ! data from plasma state in semipublic form.  Then, using the array sizes 
    ! obtained from the plasma state it allocates the input arrays declared above.
    ! and then puts the semi-public data in the module public variables above.
    !
    ! GET_PLASMA_STATE_RF is to be called from inside a component routine that 
    ! converts this data to code specific form, combines it with other code specific
    ! data as provided by initialization files and writes the standard
    ! input files for the specific code implementation e.g. AORSA.
    ! That routine might be called for example: WRITE_AORSA_INPUT_FILES.
    ! 
    !-------------------------------------------------------------------


    SUBROUTINE GET_PLASMA_STATE_RF(ierr)
    
    
        USE plasma_state_mod    ! This delares all of the Plasma State 
                                ! data with semi-public names

    
    !----------------------------------------------------------------------
    !
    !   Declare local variables
    !
    !----------------------------------------------------------------------
    
    
        INTEGER, INTENT(out) :: ierr
        
        INTEGER :: istat    ! Error flag returned by ALLOCATE function
        
    !----------------------------------------------------------------------
    !
    !   Load all semi-public Plasma State data into plasma_state_mod module
    !
    !----------------------------------------------------------------------
        
        CALL PS_GET_PLASMA_STATE(ierr)  ! This is a module routine of plasma_state_mod
    
    !----------------------------------------------------------------------
    !
    !   Allocate arrays for public name Plasma State data needed by RF_solve component
    !
    !----------------------------------------------------------------------
    
        nspec = PS_nspec

        nspec_th = PS_nspec_th
            ALLOCATE( s_name(0:nspec_th), stat=istat )
            IF (istat /= 0 ) THEN
                CALL SWIM_error ('allocation', 'GET_PLASMA_STATE_RF' , 's_name')
                ierr = istat
                RETURN
            END IF


            ALLOCATE( q_s(0:nspec_th), stat=istat )
            IF (istat /= 0 ) THEN
                CALL SWIM_error ('allocation', 'GET_PLASMA_STATE_RF' , 'q_s')
                ierr = istat
                RETURN
            END IF

            ALLOCATE( m_s(0:nspec_th), stat=istat )
            IF (istat /= 0 ) THEN
                CALL SWIM_error ('allocation', 'GET_PLASMA_STATE_RF' , 'm_s')
                ierr = istat
                RETURN
            END IF
                
        nrho_n = PS_nrho_n
        
            ALLOCATE( rho_n_grid(nrho_n), stat=istat )
            IF (istat /= 0 ) THEN
                CALL SWIM_error ('allocation', 'GET_PLASMA_STATE_RF' , 'rho_n_grid')
                ierr = istat
                RETURN
            END IF
        
            ALLOCATE( n_s(nrho_n, 0:nspec_th), stat=istat )
            IF (istat /= 0 ) THEN
                CALL SWIM_error ('allocation', 'GET_PLASMA_STATE_RF' , 'n_s')
                ierr = istat
                RETURN
            END IF
        
            ALLOCATE( q_impurity(nrho_n), stat=istat )
            IF (istat /= 0 ) THEN
                CALL SWIM_error ('allocation', 'GET_PLASMA_STATE_RF' , 'q_impurity')
                ierr = istat
                RETURN
            END IF
        
            ALLOCATE( m_impurity(nrho_n), stat=istat )
            IF (istat /= 0 ) THEN
                CALL SWIM_error ('allocation', 'GET_PLASMA_STATE_RF' , 'm_impurity')
                ierr = istat
                RETURN
            END IF
        
        nrho_T = PS_nrho_T
        
            ALLOCATE( rho_T_grid(nrho_T), stat=istat )
            IF (istat /= 0 ) THEN
                CALL SWIM_error ('allocation', 'GET_PLASMA_STATE_RF' , 'rho_T_grid')
                ierr = istat
                RETURN
            END IF
        
            ALLOCATE( T_s(nrho_n, 0:nspec_th), stat=istat )
            IF (istat /= 0 ) THEN
                CALL SWIM_error ('allocation', 'GET_PLASMA_STATE_RF' , 'T_s')
                ierr = istat
                RETURN
            END IF
        
        nrho_v_par = PS_nrho_v_par
        
            ALLOCATE( rho_v_par_grid(nrho_v_par), stat=istat )
            IF (istat /= 0 ) THEN
                CALL SWIM_error ('allocation', 'GET_PLASMA_STATE_RF' , 'v_par_grid')
                ierr = istat
                RETURN
            END IF
        
            ALLOCATE( v_par_s(nrho_v_par, 0:nspec_th), stat=istat )
            IF (istat /= 0 ) THEN
                CALL SWIM_error ('allocation', 'GET_PLASMA_STATE_RF' , 'v_par_s')
                ierr = istat
                RETURN
            END IF
                
        nspec_nonMax = PS_nspec_nonMax

            ALLOCATE( nonMax_name(nspec_nonMax), stat=istat )
            IF (istat /= 0 ) THEN
                CALL SWIM_error ('allocation', 'GET_PLASMA_STATE_RF' , 'nonMax_name')
                ierr = istat
                RETURN
            END IF


            ALLOCATE( q_nonMax_s(nspec_nonMax), stat=istat )
            IF (istat /= 0 ) THEN
                CALL SWIM_error ('allocation', 'GET_PLASMA_STATE_RF' , 'q_nonMax_s')
                ierr = istat
                RETURN
            END IF

            ALLOCATE( m_nonMax_s(nspec_nonMax), stat=istat )
            IF (istat /= 0 ) THEN
                CALL SWIM_error ('allocation', 'GET_PLASMA_STATE_RF' , 'm_nonMax_s')
                ierr = istat
                RETURN
            END IF
        
        ntheta_n = PS_ntheta_n

            ALLOCATE( n_nonMax2D_s(nrho_n, ntheta_n, nspec_nonMax), stat=istat )
            IF (istat /= 0 ) THEN
                CALL SWIM_error ('allocation', 'GET_PLASMA_STATE_RF' , 'n_nonMax2D_s')
                ierr = istat
                RETURN
            END IF

            ALLOCATE( n_nonMax_s(nrho_n, nspec_nonMax), stat=istat )
            IF (istat /= 0 ) THEN
                CALL SWIM_error ('allocation', 'GET_PLASMA_STATE_RF' , 'n_nonMax_s')
                ierr = istat
                RETURN
            END IF

            ALLOCATE( dist_fun_s(nspec_nonMax), stat=istat )
            IF (istat /= 0 ) THEN
                CALL SWIM_error ('allocation', 'GET_PLASMA_STATE_RF' , 'dist_fun_s')
                ierr = istat
                RETURN
            END IF
        
        nrf_src = PS_nrf_src

            ALLOCATE( rf_src_name(nrf_src), stat=istat )
            IF (istat /= 0 ) THEN
                CALL SWIM_error ('allocation', 'GET_PLASMA_STATE_RF' , 'rf_src_name')
                ierr = istat
                RETURN
            END IF

            ALLOCATE( rf_freq_src(nrf_src), stat=istat )
            IF (istat /= 0 ) THEN
                CALL SWIM_error ('allocation', 'GET_PLASMA_STATE_RF' , 'rf_freq_src')
                ierr = istat
                RETURN
            END IF

            ALLOCATE( rf_power_src(nrf_src), stat=istat )
            IF (istat /= 0 ) THEN
                CALL SWIM_error ('allocation', 'GET_PLASMA_STATE_RF' , 'rf_power_src')
                ierr = istat
                RETURN
            END IF

            ALLOCATE( ant_model_src(nrf_src), stat=istat )
            IF (istat /= 0 ) THEN
                CALL SWIM_error ('allocation', 'GET_PLASMA_STATE_RF' , 'ant_model_src')
                ierr = istat
                RETURN
            END IF
    !----------------------------------------------------------------------
    !
    !   Assign public variables relevant to RF component from semi-public data
    !
    !-----------------------------------------------------------------------

   
    !-----------------------------------
    ! Time at beginning and end of time step
    !-----------------------------------

        t0 = PS_t0
        t1 = PS_t1
        
    !-----------------------------------
    ! Basic Geometry
    !-----------------------------------

        r_axis = PS_r_axis
        z_axis = PS_z_axis
        r0_mach = PS_r0_mach
        z0_mach = PS_z0_mach
        r_min = PS_r_min
        r_max = PS_r_max
        z_min = PS_z_min
        z_max = PS_z_max
            
    !-----------------------------------
    ! Particle Species
    !-----------------------------------
    
        nspec = PS_nspec
    !-----------------------------------
    ! Main (thermal) Plasma Species
    !-----------------------------------
    
        nspec_th = PS_nspec_th
        s_name = PS_s_name
        q_s = PS_q_s
        m_s = PS_m_s
        nrho_n = PS_nrho_n
        rho_n_grid = PS_rho_n_grid
        n_s = PS_n_s
        q_impurity = PS_q_impurity
        m_impurity = PS_m_impurity
        nrho_T = PS_nrho_T
        rho_T_grid = PS_rho_T_grid
        T_s = PS_T_s
        nrho_v_par = PS_nrho_v_par
        rho_v_par_grid = PS_rho_v_par_grid
        v_par_s = PS_v_par_s
 
    !-----------------------------------
    ! Non-Maxwellian Species
    !-----------------------------------
    
        nspec_nonMax = PS_nspec_nonMax
        nonMax_name = PS_nonMax_name
        q_nonMax_s = PS_q_nonMax_s
        m_nonMaX_s = PS_m_nonMaX_s
        ntheta_n = PS_ntheta_n
        n_nonMax2D_s = PS_n_nonMax2D_s
        n_nonMax_s = PS_n_nonMax_s
        dist_fun_s = PS_dist_fun_s
 
 
    !-----------------------------------
    ! Magnetics    
    !-----------------------------------

        eqdsk_file = PS_eqdsk_file
        B_axis = PS_B_axis

    !--------------------------------------------------------------------------    !
    ! RF input data
    !--------------------------------------------------------------------------

        rf_src_name = PS_rf_src_name
        rf_freq_src = PS_rf_freq_src
        rf_power_src = PS_rf_power_src
        ant_model_src = PS_ant_model_src
   
    RETURN

    END SUBROUTINE GET_PLASMA_STATE_RF



    SUBROUTINE PUT_PLASMA_STATE_RF(ierr)
    
    !-------------------------------------------------------------------
    !
    ! This routine takes the rf output data declared above and then
    ! perform XPLASMA calls that put the data in the plasma state.
    ! 
    ! It will be called from inside a component routine that reads the
    ! code specific standard output files, converts it to the form declared
    ! above, then calls this WRITE_PLASMA_STATE_RF routine
    ! An example of that component routine would be: UPDATE_PS_FROM_AORSA.
    ! That routine must have previoulsy used plasma_state_rf_mod and put the
    ! output data, in proper from, into the variables declared above.
    ! 
    !-------------------------------------------------------------------

        
    !----------------------------------------------------------------------
    !
    !   Declare and make accesible the semi-public Plasma State variables from
    !   plasma_state_mod module to be updated
    !
    !----------------------------------------------------------------------
        
        use plasma_state_mod, only : &  
            PS_nrho_prf, PS_ntheta_prf, PS_nrf_src, PS_prf2D_src_s, PS_prf_src_s, &
            PS_prf_total_s, PS_nrho_cdrf, PS_cdrf_src_s, PS_cdrf_total_s, &
            PS_ql_operator, &
            PS_STORE_PLASMA_STATE
    
    
    !----------------------------------------------------------------------
    !
    !   Declare local variables
    !
    !----------------------------------------------------------------------
    
    
        INTEGER, INTENT(out) :: ierr
        
        INTEGER :: istat    ! Error flag returned by ALLOCATE function

    !----------------------------------------------------------------------
    !
    !   Allocate arrays for semi-public Plasma State data provided by RF_solve 
    !   component
    !
    !----------------------------------------------------------------------
            
        PS_nrho_prf = nrho_prf      
        PS_ntheta_prf = ntheta_prf
        PS_nrf_src = nrf_src
        
            IF ( ALLOCATED(PS_prf2D_src_s) ) DEALLOCATE (PS_prf2D_src_s)
            ALLOCATE( PS_prf2D_src_s (nrho_prf, ntheta_prf, nrf_src, nspec), stat=istat )
            IF (istat /= 0 ) THEN
                CALL SWIM_error ('allocation', 'PUT_PLASMA_STATE_RF' , 'PS_prf2D_src_s')
                ierr = istat
                RETURN
            END IF

            IF ( ALLOCATED( PS_prf_src_s) ) DEALLOCATE ( PS_prf_src_s)
            ALLOCATE( PS_prf_src_s (nrho_prf, nrf_src, nspec), stat=istat )
            IF (istat /= 0 ) THEN
                CALL SWIM_error ('allocation', 'PUT_PLASMA_STATE_RF' , 'PS_prf_src_s')
                ierr = istat
                RETURN
            END IF

            IF ( ALLOCATED(PS_prf_total_s) ) DEALLOCATE (PS_prf_total_s)
            ALLOCATE( PS_prf_total_s (nrho_prf, nspec), stat=istat )
            IF (istat /= 0 ) THEN
                CALL SWIM_error ('allocation', 'PUT_PLASMA_STATE_RF' , 'PS_prf_total_s')
                ierr = istat
                RETURN
            END IF
        
        PS_nrho_cdrf = nrho_cdrf

            IF ( ALLOCATED(PS_cdrf_src_s) ) DEALLOCATE (PS_cdrf_src_s)
            ALLOCATE( PS_cdrf_src_s (nrho_cdrf, nrf_src, nspec_nonMax), stat=istat )
            IF (istat /= 0 ) THEN
                CALL SWIM_error ('allocation', 'PUT_PLASMA_STATE_RF' , 'PS_cdrf_src_s')
                ierr = istat
                RETURN
            END IF

            IF ( ALLOCATED(PS_cdrf_total_s ) ) DEALLOCATE (PS_cdrf_total_s )
            ALLOCATE( PS_cdrf_total_s (nrho_cdrf, nspec_nonMax), stat=istat )
            IF (istat /= 0 ) THEN
                CALL SWIM_error ('allocation', 'PUT_PLASMA_STATE_RF' , 'PS_CDrf_total_s')
                ierr = istat
                RETURN
            END IF


            IF ( ALLOCATED(PS_ql_operator) ) DEALLOCATE (PS_ql_operator)
            ALLOCATE( PS_ql_operator(nspec_nonMax), stat=istat )
            IF (istat /= 0 ) THEN
                CALL SWIM_error ('allocation', 'GET_PLASMA_STATE_RF' , 'PS_ql_operator')
                ierr = istat
                RETURN
            END IF

    !--------------------------------------------------------------------------    !
    ! Load RF output data
    !--------------------------------------------------------------------------
            
            PS_prf2D_src_s = prf2D_src_s
            PS_prf_src_s = prf_src_s
            PS_prf_total_s = prf_total_s
            PS_cdrf_src_s = cdrf_src_s
            PS_cdrf_total_s = cdrf_total_s
            PS_ql_operator = ql_operator
        
    !----------------------------------------------------------------------
    !
    !   Store all semi-public Plasma State data into plasma_state
    !
    !----------------------------------------------------------------------
        
        CALL PS_STORE_PLASMA_STATE(ierr)


    END SUBROUTINE PUT_PLASMA_STATE_RF


END MODULE plasma_state_rf_mod
